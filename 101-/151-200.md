











155. Min Stack  --Easy

     Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

     - push(x) -- Push element x onto stack.
     - pop() -- Removes the element on top of the stack.
     - top() -- Get the top element.
     - getMin() -- Retrieve the minimum element in the stack.

     **Example 1:**

     ```
     Input
     ["MinStack","push","push","push","getMin","pop","top","getMin"]
     [[],[-2],[0],[-3],[],[],[],[]]
     
     Output
     [null,null,null,null,-3,null,0,-2]
     
     Explanation
     MinStack minStack = new MinStack();
     minStack.push(-2);
     minStack.push(0);
     minStack.push(-3);
     minStack.getMin(); // return -3
     minStack.pop();
     minStack.top();    // return 0
     minStack.getMin(); // return -2
     ```

     **Constraints:**

     - Methods `pop`, `top` and `getMin` operations will always be called on **non-empty** stacks.

     **Solutions:**

     155.1 use two stacks, one to work as a assist stack to record the minimum value each time. in the following code, I use a linkedlist as the assist data structure.

     ```java
     class MinStack {
         Stack<Integer> st;
         LinkedList<Integer> min;
       
         public MinStack() {
             min = new LinkedList<>();
             min.add(Integer.MAX_VALUE);
             st = new Stack<>();
         }
         
         public void push(int x) {
             if(x<min.getLast())
                 min.add(x);
             else
                 min.add(min.getLast());
           	st.push(x);
         }
         
         public void pop() {
             st.pop();
             min.removeLast();
         }
         
         public int top() {
             return st.peek();
         }
         
         public int getMin() {
             return min.getLast();
         }
     }
     ```

     155.2 store a pari data sturcutue in stack

     ```java
     class MinStack {
         Stack<Pair<Integer,Integer>> st;
     
         public MinStack() {
             st = new Stack<>();
         }
     
         public void push(int x) {
             if (st.isEmpty())
                 st.push(new Pair<>(x,x));
             else 
                 st.push(new Pair<>(x,Math.min(st.peek().getValue(),x)));
         }
     
         public void pop() {
             st.pop();
         }
     
         public int top() {
             return st.peek().getKey();
         }
     
         public int getMin() {
             return st.peek().getValue();
         }
     }
     ```

     155.3 tricky method! for each new minimum value, when we store them, we can store the previous minimum value before it. Thus, each time we pop the minimum value, we can pop the previous minimum value simply.

     ```java
     class MinStack {
         Stack<Integer> st;
             int min = Integer.MAX_VALUE;
     
             public MinStack() {
                 st = new Stack<>();
             }
     
             public void push(int x) {
                 if (x<=min) {    // = is very important
                     st.push(min);
                     min = x;
                 }
                 st.push(x);
             }
     
             public void pop() {
                 if (st.pop() == min)
                     min = st.pop();
             }
     
             public int top() {
                 return st.peek();
             }
     
             public int getMin() {
                 return min;
             }
     }
     ```





157. Read N Characters Given Read4  --Easy

     Given a file and assume that you can only read the file using a given method `read4`, implement a method to read *n* characters. 

     **Method read4:** 

     The API `read4` reads 4 consecutive characters from the file, then writes those characters into the buffer array `buf`.

     The return value is the number of actual characters read.

     Note that `read4()` has its own file pointer, much like `FILE *fp` in C.

     **Definition of read4:**

     ```
         Parameter:  char[] buf4
         Returns:    int
     
     Note: buf4[] is destination not source, the results from read4 will be copied to buf4[]
     ```

     Below is a high level example of how `read4` works:

     ![img](https://assets.leetcode.com/uploads/2020/07/01/157_example.png)

     ```
     File file("abcde"); // File is "abcde", initially file pointer (fp) points to 'a'
     char[] buf4 = new char[4]; // Create buffer with enough space to store characters
     read4(buf4); // read4 returns 4. Now buf = "abcd", fp points to 'e'
     read4(buf4); // read4 returns 1. Now buf = "e", fp points to end of file
     read4(buf4); // read4 returns 0. Now buf = "", fp points to end of file 
     ```

     **Method read:**

     By using the `read4` method, implement the method `read` that reads *n* characters from the file and store it in the buffer array `buf`. Consider that you **cannot** manipulate the file directly.

     The return value is the number of actual characters read.

     **Definition of read:** 

     ```
         Parameters:	char[] buf, int n
         Returns:	int
     
     Note: buf[] is destination not source, you will need to write the results to buf[] 
     ```

     **Example 1:**

     ```
     Input: file = "abc", n = 4
     Output: 3
     Explanation: After calling your read method, buf should contain "abc". We read a total of 3 characters from the file, so return 3. Note that "abc" is the file's content, not buf. buf is the destination buffer that you will have to write the results to.
     ```

     **Example 2:**

     ```
     Input: file = "abcde", n = 5
     Output: 5
     Explanation: After calling your read method, buf should contain "abcde". We read a total of 5 characters from the file, so return 5.
     ```

     **Example 3:**

     ```
     Input: file = "abcdABCD1234", n = 12
     Output: 12
     Explanation: After calling your read method, buf should contain "abcdABCD1234". We read a total of 12 characters from the file, so return 12.
     ```

     **Example 4:**

     ```
     Input: file = "leetcode", n = 5
     Output: 5
     Explanation: After calling your read method, buf should contain "leetc". We read a total of 5 characters from the file, so return 5.
     ```

     **Note:**

     - Consider that you **cannot** manipulate the file directly, the file is only accesible for `read4` but **not** for `read`.
     - The `read` function will only be called once for each test case.
     - You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing *n* characters.

     **Solutions:**

     157.1 use internal buffer of 4 characters

     ```java
     public int read(char[] buf, int n) {
             int cur = 0, ret = 4;
             char[] buf4 = new char[4];
             while (cur<n && ret == 4){
                 // read4() return the read length of file
               	// if the left of file is less than 4, return the left length
                 // else return 4
                 ret = read4(buf4);     
                 for (int i = 0; i < ret; i++) {
                   	// if the length of file is longer than n, it will stop
                     if(cur==n)    
                         return cur;
                     buf[cur++] = buf4[i];
                 }
             }
             return cur;
         }
     ```

     157.2 no internal buffer

     This solution is mainly suitable for the languages (C, C++, Golang) where pointers allow to append directly to the primary buffer `buf`.

     **Algorithm**

     - Initialize the number of copied characters `copiedChars = 0`, and the number of read characters: `readChars = 4`.
     - While number of copied characters is less than N: `copiedChars < n` and there are still characters in the file: `readChars == 4`:
       - Read from file directly into buffer: `read4(buf + copiedChars)`.
       - Increase `copiedChars`: `copiedChars += readChars`.
     - Now `buf` contains at least N characters. Return `min(n, copiedChars)`.

     ```c++
     class Solution {
     public:
         int read(char *buf, int n) {
             int copiedChars = 0, readChars = 4;
             
             while (copiedChars < n && readChars == 4) {
                 readChars = read4(buf + copiedChars);
                 copiedChars += readChars;
             }
           	// when n is less than the length of file, it will read all the file into buf
             return min(n, copiedChars);   
         }
     };
     ```

     



160. Intersection of Two Linked Lists   --Easy

     Write a program to find the node at which the intersection of two singly linked lists begins.

     For example, the following two linked lists:

     [![img](https://assets.leetcode.com/uploads/2018/12/13/160_statement.png)](https://assets.leetcode.com/uploads/2018/12/13/160_statement.png)

     begin to intersect at node c1.

     **Example 1:**

     [![img](https://assets.leetcode.com/uploads/2020/06/29/160_example_1_1.png)](https://assets.leetcode.com/uploads/2020/06/29/160_example_1_1.png)

     ```
     Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
     Output: Reference of the node with value = 8
     Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
     ```

     **Example 2:**

     [![img](https://assets.leetcode.com/uploads/2020/06/29/160_example_2.png)](https://assets.leetcode.com/uploads/2020/06/29/160_example_2.png)

     ```
     Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
     Output: Reference of the node with value = 2
     Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.
     ```

     **Example 3:**

     [![img](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

     ```
     Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
     Output: null
     Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
     Explanation: The two lists do not intersect, so return null.
     ```

     **Notes:**

     - If the two linked lists have no intersection at all, return `null`.
     - The linked lists must retain their original structure after the function returns.
     - You may assume there are no cycles anywhere in the entire linked structure.
     - Each value on each linked list is in the range `[1, 10^9]`.
     - Your code should preferably run in O(n) time and use only O(1) memory.

     **Solutions:**

     160.1 brute-force O(mn) + O(1)

     160.2 use hashmap to store O(m+n) + O(n)

     160.3 two pointers. 

     + Maintain two pointers a and b initialized at the head of A and B, respectively. Then let them both traverse throught their lists, one node at a time.

     + When a reaches the end of the list, then redirect it to the head of list b. Similarly, when b reaches the end of list, redirect it to the head of list a.
     + If at any point a meets b, then a/b is the intersection node.
     + [![P7OXSx.png](https://s1.ax1x.com/2018/08/24/P7OXSx.png)](https://imgchr.com/i/P7OXSx)

     ```java
     public ListNode getIntersectionNode3(ListNode headA, ListNode headB) {
             if (headA == null || headB == null)
                 return null;
             ListNode dummy1 = headA;
             ListNode dummy2 = headB;
             while (dummy1 != dummy2) {
                 dummy1 = (dummy1 == null) ? headB : dummy1.next;
                 dummy2 = (dummy2 == null) ? headA : dummy2.next;
             }
             return dummy1;
         }
     ```

     



167. Two Sum II - Input array is sorted  --Easy

     Given an array of integers that is already ***sorted in ascending order\***, find two numbers such that they add up to a specific target number.

     The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.

     **Note:**

- Your returned answers (both index1 and index2) are not zero-based.
- You may assume that each input would have *exactly* one solution and you may not use the *same* element twice.

**Example:**

```
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
```

**Solution:** 

167.1 two pointers

```java
public static int[] twoSum(int[] numbers, int target) {
        int[] res = new int[2];
        int left = 0, right = numbers.length - 1;
        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (sum > target)
                right--;
            else if (sum < target)
                left++;
            else {
                return new int[]{left + 1, right + 1};    // return directly
            }
        }
        return new int[]{-1, -1};
    }
```

167.2 use idea of binary search

```java
public int[] twoSum(int[] numbers, int target) {
        for (int i = 0; i < numbers.length; i++) {
            int tar = target - numbers[i];
            int left = i+1, right = numbers.length-1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (numbers[mid] == tar)
                    return new int[]{i + 1, mid + 1};
                else if (numbers[mid] < tar)
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return new int[]{-1,-1};
    }
```



168. Excel Sheet Column Title  --Easy

     Given a positive integer, return its corresponding column title as appear in an Excel sheet.

     For example:

     ```
         1 -> A
         2 -> B
         3 -> C
         ...
         26 -> Z
         27 -> AA
         28 -> AB 
         ...
     ```

     **Example 1:**

     ```
     Input: 1
     Output: "A"
     ```

     **Example 2:**

     ```
     Input: 28
     Output: "AB"
     ```

     **Example 3:**

     ```
     Input: 701
     Output: "ZY"
     ```
     
     **Solution:** the most important point in this problem is the mismatching. for example, for binary, we use 0,1 two numbers as digits, and each time when it reaches to '2', it carry to higher position, and the lower position updated to 0. For hexadecimal, we use 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f 15 characters as digits. And each time it reaches to '16', it will carry to higher position, and lower position updated to 0. 
     
     Thus, for this problem, we need to match 'A,B,C,D...Z' to '0,1,2,3,...25' to use the method that converting a decimal number to 26-system number.
     
     or each time, we mod 26 to get the digit from the back to front. 
     
     ```java
     public String convertToTitle(int n) {
             StringBuilder sb = new StringBuilder();
             while (n > 0){
                 n--;
                 sb.append((char)('A' + n % 26));
               	// sb.insert(0, (char)('A' + n % 26))
                 n /= 26;
             }
             return sb.reverse().toString();
         }
     ```



169. Majority Element  --Easy

     Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.

     You may assume that the array is non-empty and the majority element always exist in the array.

     **Example 1:**

     ```
     Input: [3,2,3]
     Output: 3
     ```

     **Example 2:**

     ```
     Input: [2,2,1,1,1,2,2]
     Output: 2
     ```

**Solutions:**

169.1 use map to count the frequency of each integer

```java
public int majorityElement(int[] nums) {
        int n2 = nums.length /2;
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0; i<nums.length; i++){
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
            if(map.get(nums[i])>n2)
                return nums[i];
        }
        return 0;
    }
```

169.2 sort array, then count the frequency

```java
public int majorityElement2(int[] nums) {
        Arrays.sort(nums);
        int n2 = nums.length /2;
        int count=1;
        for(int i=0; i<nums.length-1; i++){
            if(nums[i] == nums[i+1]){
                count++;
                if(count>n2)
                    return nums[i];
            }else{
                count = 1;
            }
        }
        return nums[0];
    }
```

169.3 sort array, then return the middle integer

```java
public int majorityElement3(int[] nums) {
        Arrays.sort(nums);
        int n2 = nums.length /2;
        return nums[n2];
    }
```





170. Two Sum III - Data structure design  --Easy

     Design and implement a TwoSum class. It should support the following operations: `add` and `find`.

     `add` - Add the number to an internal data structure.
     `find` - Find if there exists any pair of numbers which sum is equal to the value.

     **Example 1:**

     ```
     add(1); add(3); add(5);
     find(4) -> true
     find(7) -> false
     ```

     **Example 2:**

     ```
     add(3); add(1); add(2);
     find(3) -> true
     find(6) -> false
     ```

     **Solutions:**

     170.1 use two pointers to find. sort when add element

     ```java
     class TwoSum {
             List<Integer> ls;
             boolean isSorted;
             /** Initialize your data structure here. */
             public TwoSum() {
                 ls = new ArrayList<>();   //linkedlist will result in TLE！！！
                 isSorted = false;
             }
     
             /** Add the number to an internal data structure.. */
             public void add(int number) {      //add in the right position  
               	// O(logn) to find, O(n) to insert
                 int left = 0, right = ls.size()-1;
                 while (left <= right){
                     int mid = left + (right-left)/2;
                     if(ls.get(mid)==number){
                         left = mid;
                         break;
                     }else if (ls.get(mid)<number){
                         left = mid+1;
                     } else {
                         right = mid-1;
                     }
                 }
                 ls.add(left,number);
             }
     
             /** Find if there exists any pair of numbers which sum is equal to the value. */
             public boolean find(int value) {          //O(n)
                 int left = 0, right = ls.size() -1;
                 while(left<right){
                     int twosum = ls.get(left) + ls.get(right);
                     if (twosum == value){
                         return true;
                     } else if(twosum < value){
                         // if we consider the same element and skip, it will be slower
                         //while (left<ls.size()-1 && ls.get(left) == ls.get(left+1))
                         //    left++;
                         left++;
                     } else{
                         //while (right>0 && ls.get(right) == ls.get(right-1))
                         //    right--;
                         right--;
                     }
                 }
                 return false;
             }
         }
     ```

     Add it directly in the end. When call find(), sort if isSorted is false.

     ```java
     class TwoSum {
             List<Integer> ls;
             boolean isSorted;
             /** Initialize your data structure here. */
             public TwoSum() {
                 ls = new ArrayList<>();   //linkedlist will result in TLE！！！
                 isSorted = false;
             }
     
             /** Add the number to an internal data structure.. */
             public void add(int number) { // O(1)
     	       		ls.add(number);
           		  isSorted = false;
             }
     
             /** Find if there exists any pair of numbers which sum is equal to the value. */
             public boolean find(int value) { //O(nlogn) for sort, O(n) for find
                 if (!isSorted) {
                     ls.sort((o1, o2) -> (o1 - o2));
                     isSorted = true;
                 }
                 int left = 0, right = ls.size() -1;
                 while(left<right){
                     int twosum = ls.get(left) + ls.get(right);
                     if (twosum == value){
                         return true;
                     } else if(twosum < value){
                         while (left<ls.size()-1 && ls.get(left) == ls.get(left+1))
                             left++;
                         left++;
                     } else{
                         while (right>0 && ls.get(right) == ls.get(right-1))
                             right--;
                         right--;
                     }
                 }
                 return false;
             }
         }
     ```

     170.2 use hashmap. only note is when we can use two equal integer to sum up to the target

     ```java
     class TwoSum {
             Map<Integer,Integer> map;
             /** Initialize your data structure here. */
             public TwoSum() {
                 map = new HashMap<>();
             }
     
             /** Add the number to an internal data structure.. */
             public void add(int number) {
                 map.put(number,map.getOrDefault(number,0)+1);
             }
     
             /** Find if there exists any pair of numbers which sum is equal to the value. */
             public boolean find(int value) {
     
                 for (int num : map.keySet()){
                     int left = value-num;
                     if (left==num && map.get(left)>1)
                         return true;
                     else if (left!=num &&map.containsKey(left))
                         return true;
                 }
                 return false;
             }
         }
     ```

     

     

171. Excel Sheet Column Number  --Easy

     Given a column title as appear in an Excel sheet, return its corresponding column number.

     For example:

     ```
         A -> 1
         B -> 2
         C -> 3
         ...
         Z -> 26
         AA -> 27
         AB -> 28 
         ...
     ```

     **Example 1:**

     ```
     Input: "A"
     Output: 1
     ```

     **Example 2:**

     ```
     Input: "AB"
     Output: 28
     ```

     **Example 3:**

     ```
     Input: "ZY"
     Output: 701
     ```

     **Constraints:**

     - `1 <= s.length <= 7`
     - `s` consists only of uppercase English letters.
     - `s` is between "A" and "FXSHRXW".

     **Solution:**

     ```java
     public int titleToNumber(String s) {
             int sum = 0;
             char[] arr = s.toCharArray();
             for(int i = 0; i<arr.length; i++){
                 int digit = arr[i] - 'A' + 1;
                 sum = sum*26 + digit;
             }
             return sum;
         }
     ```



172. Factorial Trailing Zeroes  --Easy

     Given an integer `n`, return *the number of trailing zeroes in `n!`*.

     **Follow up:** Could you write a solution that works in logarithmic time complexity?

     **Example 1:**

     ```
Input: n = 3
     Output: 0
     Explanation: 3! = 6, no trailing zero.
     ```
     
     **Example 2:**

     ```
Input: n = 5
     Output: 1
     Explanation: 5! = 120, one trailing zero.
     ```
     
     **Example 3:**

     ```
Input: n = 0
     Output: 0
     ```
     
     **Constraints:**

     - `1 <= n <= 104`

     **Solutions:** we need to find the number of 5 factor of all integers

     172.1 find 5 factor for each integer. O(n)

     ```java
public int trailingZeroes(int n) {
             int i=5, cnt=0;   // start from 5
             while (i<=n){
                 int tmp = i;
                 while (tmp%5==0){
                         cnt++;
                         tmp /=5;
                 }
                 i+=5;        // add 5 each time
             }
             return cnt;
         }
     ```
     
     172.2 calculate 5 factor directly from n. O(logn)

     ```java
public int trailingZeroes(int n) {
             int cnt = 0;
             while (n>0){
                 cnt+=n/5;
                 n/=5;
             }
             return cnt;
         }
     ```
     
     

175. Combine Two Tables  --Easy

     Table: `Person`

     ```
     +-------------+---------+
     | Column Name | Type    |
     +-------------+---------+
     | PersonId    | int     |
     | FirstName   | varchar |
     | LastName    | varchar |
     +-------------+---------+
     PersonId is the primary key column for this table.
     ```

     Table: `Address`

     ```
     +-------------+---------+
     | Column Name | Type    |
     +-------------+---------+
     | AddressId   | int     |
     | PersonId    | int     |
     | City        | varchar |
     | State       | varchar |
     +-------------+---------+
     AddressId is the primary key column for this table.
     ```

     Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:

     ```
     FirstName, LastName, City, State
     ```

     **Solution:**

     ```sql
     select FirstName, LastName, City, State 
     from Person left join Address
     on Person.PersonId = Address.PersonId;
     ```



176. Second Highest Salary  --Easy

     Write a SQL query to get the second highest salary from the `Employee` table.

     ```
     +----+--------+
     | Id | Salary |
     +----+--------+
     | 1  | 100    |
     | 2  | 200    |
     | 3  | 300    |
     +----+--------+
     ```

     For example, given the above Employee table, the query should return `200` as the second highest salary. If there is no second highest salary, then the query should return `null`.

     ```
     +---------------------+
     | SecondHighestSalary |
     +---------------------+
     | 200                 |
     +---------------------+
     ```

     **Solution:**

     176.1

     ```sql
     select Max(Salary) as SecondHighestSalary
     from Employee
     where Salary<(select Max(Salary) from Employee);
     ```

     176.2 

     + limit y: read y rows
     + limt x,y: skip x rows, read y rows

     ```sql
     select Salary as SecondHighestSalary
     from (
         select distinct Salary
         from Employee
         order by Salary desc
         limit 1,1
           ) as a;
     ```

     176.3 use if null() to cover the null condition

     + limit y offset x: skip x rows, read y rows

     ```sql
     SELECT
         IFNULL(
           (SELECT DISTINCT Salary
            FROM Employee
            ORDER BY Salary DESC
             LIMIT 1 OFFSET 1),
         NULL) AS SecondHighestSalary;
     ```

     

181. Employees Earning More Than Their Managers  --Easy

     The `Employee` table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.

     ```
     +----+-------+--------+-----------+
     | Id | Name  | Salary | ManagerId |
     +----+-------+--------+-----------+
     | 1  | Joe   | 70000  | 3         |
     | 2  | Henry | 80000  | 4         |
     | 3  | Sam   | 60000  | NULL      |
     | 4  | Max   | 90000  | NULL      |
     +----+-------+--------+-----------+
     ```

     Given the `Employee` table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.

     ```
     +----------+
     | Employee |
     +----------+
     | Joe      |
     +----------+
     ```

     **Solutions:**

     181.1 slow 9%

     ```sql
     select a.Name as Employee
     from Employee a
     where a.Salary>(
     select b.Salary
     from Employee b
     where a.ManagerId = b.Id);
     ```

     181.2 77%

     ```sql
     select a.Name as Employee
     from Employee a, Employee b
     where a.Salary>b.Salary
     and a.ManagerId = b.Id;
     ```

     181.3

     ```sql
     select a.Name as Employee
     from Employee a join Employee b on a.ManagerId = b.Id
     where a.Salary>b.Salary;
     ```

     181.4 more effiecent than method 3

     ```sql
     select a.Name as Employee
     from Employee a join Employee b on a.ManagerId = b.Id
     and a.Salary>b.Salary;
     ```

     

182. Duplicate Emails  --Easy

     Write a SQL query to find all duplicate emails in a table named `Person`.

     ```
     +----+---------+
     | Id | Email   |
     +----+---------+
     | 1  | a@b.com |
     | 2  | c@d.com |
     | 3  | a@b.com |
     +----+---------+
     ```

     For example, your query should return the following for the above table:

     ```
     +---------+
     | Email   |
     +---------+
     | a@b.com |
     +---------+
     ```

     **Note**: All emails are in lowercase.

     ```sql
     select Email
     from Person 
     group by Email
     having count(Email)>1;
     ```



183. Customers Who Never Order  --Easy

     Suppose that a website contains two tables, the `Customers` table and the `Orders`table. Write a SQL query to find all customers who never order anything.

     Table: `Customers`.

     ```
     +----+-------+
     | Id | Name  |
     +----+-------+
     | 1  | Joe   |
     | 2  | Henry |
     | 3  | Sam   |
     | 4  | Max   |
     +----+-------+
     ```

     Table: `Orders`.

     ```
     +----+------------+
     | Id | CustomerId |
     +----+------------+
     | 1  | 3          |
     | 2  | 1          |
     +----+------------+
     ```

     Using the above tables as example, return the following:

     ```
     +-----------+
     | Customers |
     +-----------+
     | Henry     |
     | Max       |
     +-----------+
     ```

     **Solution:**

     ```sql
     select c.Name as Customers
     from Customers c
     where c.Id not in
     (select a.Id
     from Customers a join Orders b
     on a.Id = b.CustomerId);
     ```

     ```sql
     select a.name as Customers
     from customers a
     where a.id not in
     (
         select customerid from orders
     );
     ```



189. Rotate Array  -Easy

     Given an array, rotate the array to the right by *k* steps, where *k* is non-negative.

     **Follow up:**

     - Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
     - Could you do it in-place with O(1) extra space?

     **Example 1:**

     ```
     Input: nums = [1,2,3,4,5,6,7], k = 3
     Output: [5,6,7,1,2,3,4]
     Explanation:
     rotate 1 steps to the right: [7,1,2,3,4,5,6]
     rotate 2 steps to the right: [6,7,1,2,3,4,5]
     rotate 3 steps to the right: [5,6,7,1,2,3,4]
     ```

     **Example 2:**

     ```
     Input: nums = [-1,-100,3,99], k = 2
     Output: [3,99,-1,-100]
     Explanation: 
     rotate 1 steps to the right: [99,-1,-100,3]
     rotate 2 steps to the right: [3,99,-1,-100]
     ```

     **Constraints:**

     - `1 <= nums.length <= 2 * 10^4`
     - It's guaranteed that `nums[i]` fits in a 32 bit-signed integer.
     - `k >= 0`

     **Solutions:**

     189.1 brute-force

     ```java
     public void rotate(int[] nums, int k) {
             int n = nums.length;
             for(int i=0; i<k; i++){
                 int pre = nums[n-1];
                 for(int j=0; j<n; j++){
                     int temp = nums[j];
                     nums[j] = pre;
                     pre = temp;
                 }
             }
         }
     ```

     189.2 use extra array

     ```java
     public void rotate(int[] nums, int k) {
             int n = nums.length;
             int[] nums2 = new int[n];
             for(int i=n-1; i>=0; i--){
                 nums2[(i+k)%n] = nums[i];
             }
             for(int i=n-1; i>=0; i--){
                 nums[i] = nums2[i];
             }
         }
     ```

     ```java
     public void rotate(int[] nums, int k) {
             int[] a = new int[nums.length];
             for (int i = 0; i < nums.length; i++) {
                 a[(i + k) % nums.length] = nums[i];
             }
             for (int i = 0; i < nums.length; i++) {
                 nums[i] = a[i];
             }
         }
     ```

     189.3 



190. Reverse Bits  --Easy

     Reverse bits of a given 32 bits unsigned integer.

     **Example 1:**

     ```
     Input: 00000010100101000001111010011100
     Output: 00111001011110000010100101000000
     Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.
     ```

     **Example 2:**

     ```
     Input: 11111111111111111111111111111101
     Output: 10111111111111111111111111111111
     Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.
     ```

     **Note:**

     - Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
     - In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's_complement). Therefore, in **Example 2** above the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.

     **Follow up**:

     If this function is called many times, how would you optimize it?

     **Constraints:**

     - The input must be a **binary string** of `length = 32`

     **Solutions:**

     



191. Number of 1 Bits   --Easy

     Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).

     **Example 1:**

     ```
     Input: 00000000000000000000000000001011
     Output: 3
     Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
     ```

     **Example 2:**

     ```
     Input: 00000000000000000000000010000000
     Output: 1
     Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
     ```

     **Example 3:**

     ```
     Input: 11111111111111111111111111111101
     Output: 31
     Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
     ```

     **Note:**

     - Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.

     - In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's_complement). Therefore, in **Example 3** above the input represents the signed integer `-3`.

       **Solution:**

       ```java
       public int hammingWeight(int n) {
               int count = 0;
               while (n!=0){
                   count += n & 1;
                   n >>>= 1;   // >> means move to right one bit and highest complement symbol bit
                 							// >>> means move to right one bit and hightest complement 0
               }
               return count;
           }
       ```

       



198. House Robber   --Easy

     You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

     Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight **without alerting the police**. 

     **Example 1:**

     ```
     Input: nums = [1,2,3,1]
     Output: 4
     Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
                  Total amount you can rob = 1 + 3 = 4.
     ```

     **Example 2:**

     ```
     Input: nums = [2,7,9,3,1]
     Output: 12
     Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
                  Total amount you can rob = 2 + 9 + 1 = 12. 
     ```

     **Constraints:**

     - `0 <= nums.length <= 100`
     - `0 <= nums[i] <= 400`

     **Solutions: **classic dynamic problem

     ```java
     public int rob(int[] nums) {
             if (nums == null | nums.length == 0)
                 return 0;
             if (nums.length == 1)
                 return nums[0];
             int n = nums.length;
             int[] dp = new int[n];
             dp[0] = nums[0];
             dp[1] = Math.max(nums[0], nums[1]);
             for (int i = 2; i < n; i++) {
                 dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
             }
             return dp[n - 1];
         }
     ```

     Because the current value just relates to the last and last last one, thus we can use two variables to record.

     ```java
     public int rob(int[] nums) {
             if (nums == null | nums.length == 0)
                 return 0;
             if (nums.length == 1)
                 return nums[0];
             int preMax = 0, curMax = 0;
             for(int i : nums){
                 int temp = curMax;
                 curMax = Math.max(preMax+i, curMax);
                 preMax = temp;
             }
             return curMax;
         }
     ```

     



200. Number of Islands   --Medium

     Given a 2d grid map of `'1'`s (land) and `'0'`s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 

     **Example 1:**

     ```
     Input: grid = [
       ["1","1","1","1","0"],
       ["1","1","0","1","0"],
       ["1","1","0","0","0"],
       ["0","0","0","0","0"]
     ]
     Output: 1
     ```

     **Example 2:**

     ```
     Input: grid = [
       ["1","1","0","0","0"],
       ["1","1","0","0","0"],
       ["0","0","1","0","0"],
       ["0","0","0","1","1"]
     ]
     Output: 3
     ```

     **Solutions:**

     200.1 BFS

     ```java
     public static int numIslands(char[][] grid) {
             if (grid == null || grid.length == 0)
                 return 0;
             int row = grid.length;
             int col = grid[0].length;
             int count = 0;
             int[][] dire = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};
             for (int i = 0; i < row; i++) {
                 for (int j = 0; j < col; j++) {
                     if (grid[i][j] == '1') {
                         grid[i][j] = '0';
                         Queue<Integer> queue = new LinkedList<>();
                         queue.add(i * col + j);         //use i*col+j to record
                         while (!queue.isEmpty()) {
                             int num = queue.poll();
                             int rown = num / col;       //reduce col and row after retrieving
                             int coln = num % col;
                             for (int l = 0; l < 4; l++) {
                                 int rowd = rown + dire[l][0];
                                 int cold = coln + dire[l][1];
                                 if (rowd < 0 || rowd >= cow || cold < 0 || cold >= col)
                                     continue;
                                 else {
                                     if (grid[rowd][cold] == '1') {
                                         queue.add(rowd * col + cold);   //after finding 1 add it to queue 
                                         grid[rowd][cold] = '0';         //and reset it to 0  
                                     }
                                 }
                             }
                         }
                         count++;
                     }
                 }
             }
             return count;
         }
     ```

     200.2 DFS

     ```java
     public static int numIslands2(char[][] grid) {
             if (grid == null || grid.length == 0) {
                 return 0;
             }
     
             int row = grid.length;
             int col = grid[0].length;
             int count = 0;
             for (int i = 0; i < row; i++) {
                 for (int j = 0; j < col; j++) {
                     if (grid[i][j] == '1') {
                         helper(grid, i, j);
                         count++;
                     }
                 }
             }
             return count;
         }
     
         public static void helper(char[][] grid, int i, int j) {
             int row = grid.length;
             int col = grid[0].length;
             if (i >= row || j >= col || i < 0 || j < 0 || grid[i][j]=='0') {
                 return;
             }
             grid[i][j] = '0';
     
             helper(grid, i + 1, j);
             helper(grid, i - 1, j);
             helper(grid, i, j + 1);
             helper(grid, i, j - 1);
     
         }
     ```

     